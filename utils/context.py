import os
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"

import numpy as np
import tensorflow as tf

np.set_printoptions(threshold=np.inf)
os.environ["CUDA_VISIBLE_DEVICES"] = "-1"


class Context:
    '''
    model is the function under testing
    seed is the original example
    ae_from_seed is an adversarial example generated by the other techniques
    ep is the radius to generate test cases surrounding ae_from_seed
    k is the number of test cases to generate surrounding ae_from_seed
    '''
    def __init__(self, model, ae, ae_label, ep=0.01, k=20):
        self.ae = ae
        self.ae_pred_vector = model(self.ae).numpy()
        self.ae_pred_label = ae_label
        self.ep = ep
        self.k = k

        test_suite = []
        zero_one_array = np.concatenate((np.ones(int(self.ae.shape[0] * self.ae.shape[1] * self.ae.shape[2] * self.ae.shape[3] / 2)), -1 * np.ones(int(self.ae.shape[0] * self.ae.shape[1] * self.ae.shape[2] * self.ae.shape[3] / 2))))
        for i in range(self.k):
            np.random.shuffle(zero_one_array)
            noise = zero_one_array.reshape(self.ae.shape)
            new_test_ae = self.ae + self.ep*noise
            new_test_ae = tf.clip_by_value(new_test_ae, clip_value_min=0.0, clip_value_max=1.0)
            test_suite.extend(new_test_ae)
        self.prediction_matrix = model(np.array(test_suite)).numpy()

    def similarity(self):
        '''
        the cosine similarity between the confidence of the prediction label of the seed and a list of 1
        '''
        A = np.array(self.prediction_matrix[:, self.ae_pred_label])
        B = np.array([1.0]*self.k)
        return np.dot(A, B) / (np.linalg.norm(A) * np.linalg.norm(B))

    def distance(self):
        '''
        the average distance between the confidence of the prediction label of the seed and a list of 1
        '''
        A = np.array(self.prediction_matrix[:, self.ae_pred_label])
        B = np.array([1.0]*self.k)
        return np.array(B-A).mean()

    def sample_prediction(self):
        return self.prediction_matrix
